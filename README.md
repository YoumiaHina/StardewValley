
## 1 复杂的天气系统
    游戏场景中实现了每日不同的天气，包括晴、雨、雪等，不同的天气会对农场的作物等产生相应的影响。在雨天时移动速度慢，晴天时移动速度快。

![alt text](readmeImage/weather.png)

## 2 市场经济系统
    玩家的可以通过出售农产品来获取金钱，不同时期不同农产品的价格会动态调整。

![alt text](readmeImage/money.png)
## 3 游戏存档功能
    玩家可以在退出游戏后点击load加载之前的存档，这是游戏可玩性必不可少的一部分。

## 4 游戏打包成`.msi`安装包，可直接在windows系统上安装
    将游戏打包，可使用安装包下载安装应用，易于分布和分发、提高安全性和用户体验。

游戏安装包分享在夸克网盘   https://pan.quark.cn/s/26de39d60be9

![alt text](readmeImage/install.png)

## 5 统一的代码风格和完善的类的继承和设计
    本项目的代码风格统一，注释完备，结构清晰，实现了高内聚低耦合。
    
## 6 流畅的动画和多样的音乐音效
    本项目不仅有良好的代码风格，也有流畅的动画和多样的音乐音效，充分考虑到了UI设计和用户的实际游玩体验。

## 7 与原游戏相同的操作逻辑
    还原了与原游戏相同的的操作逻辑，游戏运行不会闪退，十分流畅，用户体验更好。
    
## 8 三人完成项目，少于额定人数（四人）

## 9 本项目完成了期末项目文档要求中的所有基础功能和拓展功能
    

# 项目概述

**项目名称**: 星露谷物语类游戏

**引擎**: Cocos2d-x

**开发语言**: C++

**开发环境**：VS 2022; Cocos2d-x-3.17.2

**平台**: PC (Windows)

**游戏类型**: 模拟经营，角色扮演（RPG）

**项目描述**:  本项目是一个基于《星露谷物语》玩法的模拟经营类游戏，玩家通过种植农作物、养殖动物、与村民互动等日常活动来逐步建设并经营自己的农场。游戏的核心玩法包括农业、养殖、钓鱼、社交、探险、技能升级等。

![](readmeImage/welcomeScene.png)


# 游戏核心功能

## 游戏场景
- **场景**: 游戏的世界包括多个区域，如农场、海滩、洞穴等。玩家可以自由在这些场景中移动，并与其他 NPC 互动。
- 农场 
- ![](readmeImage/crop5.png)
- 海滩
- ![](readmeImage/beach.png)
- 洞穴
- ![](readmeImage/cave.png)
- 森林
- ![](readmeImage/forest.png)


## 玩家角色

- **玩家角色控制**: 玩家控制主角进行日常操作，如走动、采集、与 NPC 互动等。通过键盘、鼠标操作。

- **属性系统**: 玩家的属性包括在社区中的声望、不同技能点构成的技能树。

- **技能树**：玩家的角色技能树包裹农业、采矿、钓鱼、料理四个技能，按键盘E键打开。相应操作每完成一定次数后技能等级增加；同时等级越高相应操作时间越短或获取概率越高。

## 农场管理

- **耕种与收获**: 玩家可以对土地进行开垦并选择种植不同种类的作物，管理土地，浇水，施肥并等待作物成熟。
- **干旱威胁**：当一段时间不对作物进行浇水操作时作物死亡，此时需要移除作物才能进行下一轮种植。
- **病害威胁**：不同作物的不同生长阶段会随机产生病害，病害产生的概率随季节与天气发生变化。病害可用农药进行去除。当一段时间未处理时，作物死亡。

- **动物养殖**: 玩家可以饲养动物，如鸡、牛、羊等，并收集动物产品如鸡蛋、牛奶等。

- **钓鱼** : 本游戏设计了丰富的钓鱼场景

- ![](readmeImage/fishing.png)

- **烹饪**
  
- ![](readmeImage/cook.png)

- **农场资源管理**：农场水资源有限且需定期进行补充，实现了水资源的管理。同时对种植的种子和肥料进行存储管理。

## 物品管理

- 玩家可以通过种植、挖掘、钓鱼、采集等方式获得各种物品，物品包括种子、工具、资源等。

## 社交系统

- **NPC 互动**: 游戏中有多个村民，玩家可以通过赠送礼物、聊天等方式与他们建立不同的关系，包括初始的陌生、友谊、浪漫关系。

- **任务系统**: 游戏内相应的npc有相应的任务，玩家可以接受这些任务，获取奖励并推动剧情发展，任务包括提交收集物品和修复建筑，任务完成后将提高玩家声望值并给出奖励。

  ![](/readmeImage/levi.png)

## 时间系统

- 游戏内有日期和季节变化，农场内物品会随时间变化而发生不同的事件，玩家可以在特殊的时间内完成任务，包括节日庆典和社区活动。

## 天气系统

- 游戏场景中实现了每日不同的天气，包括晴、雨、雪等，不同的天气会对农场的作物等产生相应的影响。在雨天时移动速度慢，晴天时移动速度快。

## 市场系统

- 玩家的可以通过出售农产品来获取金钱，不同时期不同农产品的价格会动态调整。

## 存档功能

- 玩家可以在退出游戏后点击load加载之前的存档，这是游戏可玩性必不可少的一部分。

# 技术架构

## 游戏引擎

- **Cocos2d-x**: 使用 Cocos2d-x 引擎进行游戏开发，提供了灵活的场景管理、物理引擎和动画支持。
- **UI框架**: 使用 Cocos2d-x 内置的 UI 元素，如按钮、文本框、图片等，搭建游戏的用户界面。

## 面向对象编程

- **封装**：
  -  所有的组件都封装在类中， 在不同的场景中调用封装好的组件。
  - 公有接口，私有实现：数据和操作这些数据的函数组合在一起，并限制外部直接访问数据。
  - 保护数据安全，同时隐藏实现细节，使代码更加模块化。
- **继承和多态**: 
  - 不同的类之间有继承关系
  - 代码复用，通过继承基类共享通用功能
  - 灵活扩展功能，避免重复代码
  - 解耦模块间的依赖

# 项目特色


## 代码风格统一规范

在本项目的开发过程中，我们严格遵守了既定的编码规范与命名约定，使得代码在可读性、可维护性以及可扩展性方面都保持较高水准。以下是项目中对**代码风格**所作的统一要求：

1. **命名规范**

   - **类名（Class）**：采用首字母大写的方式，后续单词也首字母大写（如 `FarmMap`, `Player`, `ItemFactory`）。
   - **函数名（Method/Function）**：采用小驼峰式命名（CamelCase），首字母小写，后续单词首字母大写（如 `getInstance()`, `moveMapByDirection()`）。
   - **成员变量（Member Variables）**：采用小驼峰的方式命名（如 `itemName`, `playerMoney`）。
   - **全局或文件内常量（Constants）**：全部字母大写并使用下划线分割（如 `PLAYER_INITIAL_MONEY`, `WINSIZE`）。
   - **命名含义清晰**：变量、函数、类名力求简洁且自解释，不使用无意义缩写；在名称中体现功能或含义，如 `isCollidable`, `mapUpdateByTime()` 等。

2. **文件组织和注释**

   - 文件头注释：每个`.h`或`.cpp` 文件顶部都有简要注释，说明该文件的功能与作者信息，类似如下格式：

     ```cpp
     /****************************************************************
      * File Function: 实现XXXX功能
      * Author:        XXX
      ****************************************************************/
     ```

   - **类/函数注释**：对于类或函数的关键逻辑，会在声明或定义处使用简要注释描述其作用、参数、返回值或特殊注意事项。

   - **实现与声明分离**：头文件(`.h`)只做类的声明、接口的定义、常量的声明；源文件(`.cpp`)中完成具体实现，并在必要时添加实现细节注释。

   - **抽象基类和接口类**：在类定义前加注释标明这是一个抽象基类（如 `Item`）或接口类，提醒其他开发者该类不能直接实例化，需要派生后使用。

3. **排版与格式**

   - **缩进和空格**：统一使用四个空格进行缩进；运算符两侧保持适度空格（如 `x = y + z`）；函数参数列表中的逗号后也应有空格。

   - 花括号（大括号）风格：采用 K&R 风格，即在函数或控制语句后紧随 `{`，例如：

     ```cpp
       if (condition) {
             // ...
       } 
       else {
             // ...
       }
     ```

   - **每行只做一件事**：避免同一行出现多种操作，保证代码逻辑可追踪、易读。如需要多步操作时，分多行进行。

   - **空行与分段**：逻辑相关但独立的代码块间使用空行隔开，增强可读性；不在文件末尾留多余空行。
   
4. **一致的代码结构**

   - **头文件顺序**：在各个 `.cpp` 文件中包含头文件时，先包含与自身类对应的头文件，然后是Cocos2d-x系统头文件或其他模块头文件，再往后是项目内部其他模块的头文件。
   - **单例类**：如 `FarmMap`, `Player` 等单例使用静态指针 `instance` 与 `getInstance()`，并在 `.cpp` 中定义静态成员，避免多处重复。
   - **资源管理**：使用清晰的资源路径（如 `ResPath::STAND_DOWN`）或统一的宏常量（如 `SOIL_GID`）来管理图片、音频等资源，避免硬编码。

5. **示例：`Item` 和 `ItemFactory` 中的风格实践**

   - `Item.h` 中采用抽象基类的方式，声明了纯虚函数 `init()` 和 `useItem()`，并在头文件顶部添加文件功能注释、作者信息。
   - `ItemFactory.h` 中使用工厂模式创建不同的物品，函数 `createItem()` 返回多态基类 `Item*`，并根据字符串识别特定的具体类；函数体内使用大量 `if-else` 分支，且使用 `CCLOG` 提示未知物品名。
   - 命名上，如 `axe`, `pickaxe`, `kettle` 等参数名称直观地反映了物品功能；相关类命名如 `Axe`, `Pickaxe`、`Kettle` 也与物品类型一一对应，增强可读性。

6. **可读性与可维护性**

   - **减少神秘数字**：常量或枚举统一放在 `Constant.h` 或相关宏定义中，禁止出现魔法数字（Magic Number）。
   - **拆分函数**：对于过长或逻辑复杂的函数，将功能相对独立的部分提取为子函数，降低单个函数的复杂度；如在 `FarmMap` 中对不同地形交互拆分为 `interactWithSoil()`, `interactWithGrass()`, `interactWithStone()` 等。
   - **简洁清晰的逻辑**：在流程较长的函数中，以注释或空行分隔不同逻辑阶段，帮助读者快速理解功能走向。

7. **const的合理使用**
   我们在能用const修饰的地方都用了const修饰，包括局部变量，成员函数，成员变量等。

通过以上约定和实践，本项目在开发过程中始终保持了**一致、清晰、可读**的代码风格，为团队协作和后续维护提供了良好的基础。若在后续迭代中有新的风格要求或最佳实践出现，也将及时更新到本规范中。


# 类的架构

## Player（单例）

    键盘上下左右控制移动，鼠标左键使用工具。

## Bag（单例）

    鼠标滚轮选择背包中的物品，按键1-9也可以直接选择背包第一排的物品。
    
    选中的物品非工具时可以使用键盘Q键移除。
    
    有新的物品获取时，若背包非空则顺序加到背包中，相同的物品按数量不重复显示。

## Control（单例）

    对游戏中所有键盘和鼠标监视器进行初始化和控制。
    
    包括玩家移动、物品丢弃、烹饪、键盘选择物品的键盘监视器，和鼠标滚轮选择物品、右键条件打开对话框的鼠标监视器。

## Event

`CommunityEvent`

    社区特殊事件

`Festival`

    特殊节日庆典，继承了CommunityEvent类。

## Manager

`DateManage`

    进行游戏时间的管控，一定时间增加游戏日期。

`WeatherManager`

    进行游戏天气的管控，包括晴天、雨天、雪天。对作物和动物生长产生影响。晴天时Animal的移动速度较快，其他时较慢。

## DialogueBox

    用于打开玩家与npc的对话框和noticeBoard的对话框。Player在可打开对话框对象附近一定距离内使用鼠标右键则打开对话框，此后根据内容不同使用鼠标左键推进/选择、使用键盘Q键赠送npc礼物等。

## Item

`Item`为物品的抽象基类，用于表示玩家背包中的物品，

- `AnimalItem`抽象类及其派生类

  用于表示背包中的动物，玩家可以使用动物物品进行农场养殖

- `Food`抽象类及其派生类

  用于表示背包中的食物，玩家可以交易食物获取金币，也可以饲养动物，也可以自己食用增加生命值

- `CampFire`类

  在玩家初次使用鱼竿钓到第一条鱼后解锁。玩家在选择背包中Food类Item的时候靠近篝火，使用键盘C键可以进行烹饪当前食物。

- `StoneItem`类

  表示玩家获得的石头，可以用于交易

- `Tool`抽象类及其派生类

  用于表示玩家的工具，包括十字镐、锄头、镰刀、种子等，用于农场耕地、作物收获、敲击石头等诸多场景

![Item](readmeImage/Item.png)

## Map

 - `BeachMap`

   从农场场景向下即可走到

 - `SceneMap`

## Skill

 - `Skill`

   包括技能名称、最大等级、当前等级及不同效果

 - `SkillTree`

   集成了农业、钓鱼、烹饪、采矿的技能树，最高等级均为五级。

   农业：每种植五次植物升级，级别越高，采摘植物时获得第二份的概率越大。

   钓鱼：每钓到五次鱼类升级，级别越高钓鱼成功率越高。

   烹饪：每完成五次烹饪升级，级别越高一次烹饪所需时间越短。

   采矿：每挖下五块石头升级，级别越高，挖取时获得第二份石头的概率越大。

 - `SkillTreeUI`

   用于展示技能树的点数。使用键盘E键展开关闭。随玩家行动自动升级。

## Npc

    靠近后右键进行对话和其他选项（赠送礼物、接受任务、查看关系）

 - `Wizaed Yuuu`
   特殊任务：提交一只金枪鱼，之后获得随机数量的石头

 - `Cleaner Levi`
   特殊任务：在海滩地图找到告示牌，完成建筑修建，之后获得随机数量的金枪鱼

 - `noticeBoard`
   同样靠近后右键对话，若背包中含有三个及以上石头可以选择提交，提交后修建成功建筑，告示牌消失。

## Animal

 - `Animal`抽象基类

   定义了动物的通用属性（例如名称、位置、移动方式），动物的随着时间成长，并产出相应的物品

 - `Cow、Chicken、Sheep、Pig`类

   继承自Animal抽象基类，不同动物既有对通用属性的实现，也有各自的新的方法、属性与行为逻辑

 - `AnimalManager`类

   用于统一管理农场上的动物资源，包括动物随时间的生长、位置以及与玩家的交互。

 ### Crop

  - `Crop`抽象基类

    Crop 作为所有作物类的抽象基类，定义了作物在农场中的通用属性和方法，例如名称、生长阶段、是否遭受干旱、病害等。子类在继承时可以覆盖（override）某些方法，以实现不同作物的生长周期、收获产物以及特殊逻辑。

  - `DogbaneCrop、CornCrop、CarrotCrop`类

    继承自Crop抽象基类，有各自的不同的生长阶段。不同的生长阶段有不同的天数，以及在不同阶段、以及有着不同的病害逻辑，成熟后可以进行收获，并出售。

### **Weather**

- `WeatherManager`类

  WeatherManager 类用于管理全局的天气，可以产生晴天、小雨、暴雨、雪等不同天气状况并在地图上呈现。该类根据当前的季节，调整不同季节下不同天气的产生概率。不同的天气会对市场商品价格、作物生长以及动物的行为产生相应的影响。

### Maket

- `MarketState`类

  MarketState 类用于管理游戏或系统中的整体市场状态，包括市场中的商品种类、市场价格波动以及完成玩家与市场的交互的交易逻辑接口。

- `MarketGood`类

  MarketGood 类用于描述单个商品在市场中的具体信息和状态，包括名称、基础价格、当前价格等。商品会根据基础价格以及当前的天气、供需价格以及季节动态调整当前的售卖价格。

# 开发流程

## 初期阶段

- **需求分析**: 了解游戏核心玩法，设计游戏角色、场景、工具等。
- **原型设计**: 根据需求设计游戏的核心原型，特别是玩家控制、场景切换、物品管理等功能。
- **项目结构搭建**: 使用 Cocos2d-x 初始化项目，搭建文件结构，准备好游戏的基础模块。

## 迭代阶段

- **场景与地图制作**: 设计和制作农场等游戏场景。
- **玩家行为系统**: 实现玩家角色的行为，包括走动、与物品互动、与 NPC 对话等。
- **任务与事件系统**: 设计并实现任务机制，设计事件触发机制。
- **农场管理系统**: 实现作物生长、养殖动物等玩法。

## 后期阶段

- **测试与调优**: 进行功能测试，修复游戏中的 bug，调优游戏的平衡性。



# 开发中遇到的问题及解决方法

## 内存管理

内存管理在项目开发过程中是一个相对高频且容易被忽视的环节，稍有不慎就会导致空指针、野指针或内存泄漏。下面总结了本项目中遇到的一些典型问题及对应的解决措施。

### 空指针问题

1. **对象被过早释放：**
    在使用 Cocos2d-x 时，常见的坑在于 `create()` 出来的对象如果**未被添加到父节点**或未被显式保留（`retain()`），在当前函数的生存期结束后（或下一帧）就会被自动释放。
   - 解决措施：
     - 将节点对象及时执行 `addChild()`，保证它的引用计数正确增加；或在确有需要的情况下，使用 `retain()` 保持其在当前函数后依旧存在，但要注意与 `release()` 成对使用，避免长期占用内存或内存泄漏。
     - 随时跟踪对象所处的“**父子关系**”或“**owner**”，避免误用已经被释放的对象。
2. **Cocos2d-x 引用计数机制的正确使用：**
   - **原理：** Cocos2d-x 中大部分继承自 `Ref` 的对象都使用引用计数来统一管理内存。当一个对象的引用计数为 0 时，引擎会自动释放它；当调用 `retain()` 时引用计数加 1，调用 `release()` 时引用计数减 1。
   - 注意事项：
     - 部分场景下（如工具函数创建临时对象）不需要手动 `retain()`，而是直接依赖 `autorelease()` 配合父节点来管理生命周期。
3. **临时对象与作用域**
   - 在函数内部创建的临时对象若未被父节点管理（`addChild()`），超出该函数作用域后对象可能被引擎自动回收，导致后续访问空指针。
   - **解决措施：**在临时对象确实需要保留时，要么加到适当的父节点里，要么自己调用 `retain()`，并在不需要时 `release()`。

### 野指针问题

1. **单例生命周期管理：**
   - 单例对象通常在游戏整个周期内存在，但如果在某些场景中提前清理或在退出时未正确销毁，就可能产生野指针或重复释放问题。
   - 解决措施：
     - 为每个单例类（如 `FarmMap`、`Player`）在 `.cpp` 中定义一个静态指针 `instance` 并将其初始化为 `nullptr`；
     - 在析构函数中将该指针置回 `nullptr`，防止后续不恰当的访问；
     - 在需要销毁单例对象的场景，先调用自定义的 `destroyInstance()`（或在退出时保证不再调用任何成员函数）以确保安全。
2. **静态全局变量和对象**
   - 静态全局对象在程序执行期间常驻内存，若其内部引用了已销毁的对象，会导致野指针访问。
   - 解决措施：
     - **尽量减少**或**避免**使用带动态内存的静态全局对象；若无法避免，需要保证相关资源在正确时机释放；
     - 在 Cocos2d-x 应用中，绝大多数场景可以通过单例或引擎本身的生命周期管理来替代静态全局对象的使用。
3. **跨场景指针持有**
   - 当一个指针指向另一个场景的对象，而该场景被销毁或替换时，可能导致指针失效。
   - 解决措施：
     - 场景切换时，通过父节点移除来管理被切换场景中对象的生命周期；
     - 在新场景中只持有仍然有效的对象引用（如单例、全局管理器），并在离开场景前确保指针不会再被后续访问。

### 具体示例：空指针与野指针的排查流程

- **空指针排查**：
  1. 检查对象是否已 `addChild()` 到父节点；
  2. 如果没有，确认是否在函数结束前被自动释放；
  3. 是否在其他地方调用过 `release()` 或被场景切换销毁。
- **野指针排查**：
  1. 检查单例类是否在析构后 `instance` 仍然被访问；
  2. 场景切换时，是否有跨场景持有指针；
  3. 静态变量或全局指针，生命周期是否和对象使用时机匹配。

## 事件的互斥

在本项目中，角色移动、对话交互、物品使用、NPC 交流等操作都依赖事件（如键盘、鼠标监听）进行触发。若缺少对事件“互斥”的考虑，容易出现同一帧内多个事件竞态执行，造成下列问题：

- **正在对话时角色仍可走动**：对话框没有被关闭或处理完毕，玩家已在场景中四处移动，造成界面混乱。
- **人物走动与使用工具冲突**：玩家刚要使用工具时被走动事件抢占，导致二者动画同时播放。
- **方向移动动画叠加**：在同一时刻触发上下和左右方向移动，动画切换频繁闪烁。

为了确保玩家交互的**自然**与**一致**，我们在项目中采取了以下措施来实现**事件的互斥**：

### 互斥需求分析

1. **对话框按钮 vs. 人物移动**
    当显示对话框（`DialogueBox`）时，玩家的移动输入应被屏蔽（或暂停监听），避免边对话边走动的场景。
2. **人物移动 vs. 使用工具**
    使用工具（如在 `Control::initMouseListener()` 中检测鼠标左键按下，调用 `player->useCurrentItem()`）需要暂时停止移动输入，确保工具使用动画或物品逻辑不被打断。
3. **多人或多事件多监听器**
    如果将来在 UI 层面添加更多交互（如背包、商店购买界面等），也要避免角色可以同时移动、使用物品、打开商店，导致各种事件重叠。

###  采用 Cocos2d-x 的事件监听机制

####  监听器优先级

- Cocos2d-x 提供基于优先级（Priority）或节点层级（SceneGraphPriority）的事件监听模式。

- 思路：
  - 对话框事件监听器（用来捕获点击“关闭对话”之类操作）可设置较高优先级，一旦对话框可见，就先截获任何输入事件，从而阻止角色层或地图层事件继续处理。
  - 当对话框隐藏后，再恢复角色移动等低优先级监听器的事件处理。

####  暂停/恢复监听器

- Cocos2d-x 允许通过 `pauseEventListenersForTarget(node)` 或 `resumeEventListenersForTarget(node)` 来暂停/恢复某个节点及其所有子节点的事件监听。

- 示例：
  - 在 `Control::initKeyboardListener()` 或其他逻辑点，侦测到对话框打开时，执行 `pauseEventListenersForTarget(Player::getInstance())`，暂停对玩家移动的响应。
  - 当对话框关闭时，执行 `resumeEventListenersForTarget(Player::getInstance())` 以允许玩家移动。

#### 全局状态判断

- 在游戏逻辑中常定义一个 `PlayerState` 或 `GameState`，如 `Idle`, `Moving`, `Dialogue`, `UsingTool` 等枚举。

- 在事件回调中，根据当前状态决定是否执行对应的事件逻辑，例如：

  ```cpp
  if (Player::getInstance()->getState() == PlayerState::Dialogue) {
      // 当前正处于对话状态，则忽略移动或使用工具的事件
      return;
  }
  ```

- `Control::updateMovement()` 中也可以先判断 `if (DialogueBox::getDialogueVisible()) ... ` 来阻止继续进行移动方向计算。

### 在 `Control` 类中的互斥实践

1. **对话框 vs. 鼠标点击**
    在 `initMouseListener()` 中：

   ```cpp
   if (mouseEvent->getMouseButton() == EventMouse::MouseButton::BUTTON_LEFT) {
       if (!DialogueBox::getDialogueVisible()) {
           // 没有对话框时，才能使用物品或交互
           player->stopMoving();
           sceneMap->stopMoving();
           player->useCurrentItem();
           sceneMap->interactWithMap();
       }
   }
   ```

   当**对话框可见**时，左键点击将优先被对话框层处理，从而阻止 `player->useCurrentItem()` 等逻辑。

2. **使用工具 vs. 移动**

   - 在 `onKeyPressed` 与 `onKeyReleased` 中，把当前按下的键加入或移出 `keysPressed` 集合。若玩家此时正处在使用工具的过程，则可以在此逻辑前判断，若 `PlayerState == UsingTool` 就暂时忽略移动指令或停止移动指令。
   - 或者在 `useCurrentItem()` 时设置 `Player::getInstance()->setUseItemEnable(false)`，阻止在使用工具动画播放期间调用 `moveByDirection()`。

3. **4 个方向动画的互斥**
    在 `Player::moveByDirection()` 中已经处理了方向判断逻辑，并避免同帧内重复切换不同方向动画。当出现多键同时按下时，通过 `direction.normalize()` 计算合成方向，保证只播放一个方向动画。

###  小结

综上所述，在本项目中，对**事件互斥**的处理主要通过：

1. **事件监听器优先级**及**暂停/恢复**机制：对话框或特殊 UI 时，提高优先级或暂停低优先级监听器。
2. **项目内全局状态判断**：对话框显示、使用工具、打开技能树等状态下阻止其他操作。
3. **合理的事件回调逻辑**：在 `Control::initKeyboardListener()`、`initMouseListener()` 内对玩家输入进行细化判断，保障同一时间只进行一项动作。

通过上述做法，我们在项目中成功避免了典型的事件混乱现象，不仅保证了游戏逻辑的一致性，也提升了玩家体验和程序稳定性。

## 坐标转换问题

在使用Cocos2d-x进行游戏或应用开发时，常常涉及坐标系与坐标转换。坐标逻辑的混淆可能会导致地图在渲染时上产生偏差，人物移动时逻辑交互出现严重错误。在游戏刚开始时，我们没有对坐标转换的逻辑清晰理解，因此我们出现了农场tmx瓦点地图无法正确加载，人物移动时的碰撞检测没有实现等诸多问题。以下是我们对坐标转换的理解：

1. **世界坐标系**

   在cocos2d-x中，世界坐标系指的是场景(Scene)的坐标系，所有节点（Node）都处于同一个世界坐标系。在cocos2d-x中，世界坐标系默认原点(0,0)在屏幕的左下角，同时x轴向右，y轴向上。

2. **TMX瓦点地图坐标**

   在瓦点地图中，我们需要去区分瓦片坐标与像素坐标两个概念：

   - 瓦片坐标：瓦片是瓦点地图中的最小单位，对应Tiled里的一格格子。瓦片坐标也称为格子坐标，通常以（col，row）表示瓦片在地图中的行号、列号。瓦片的坐标的原点默认在地图中的左上角，向右为x轴，向下为y轴。
   - 像素坐标：像素坐标指的是相对地图左上角的实际渲染位置，其坐标原点在地图的左上角，向右为x轴，向下为y轴

3. **世界坐标系->TMX瓦点地图坐标**

   为了实现人物与瓦点地图的正常交互，我们需要完成从世界坐标系往TMX瓦点地图坐标的转换，大转换步骤可以分为以下两步：

   （1）**将世界坐标系转化为瓦点地图的像素坐标**：首先我们通过Player玩家类获得当前人物在世界坐标系下的位置，再	通过SceneMap类获得当前地图在世界坐标系下的位置，接着我们通过玩家位置在世界坐标系下的位置减去地图

   ​	在世界坐标系下的位置得到玩家在瓦点地图中像素坐标位置

   （2）**将瓦点地图的像素坐标转化为瓦片坐标**：我们将像素坐标中的x除以瓦点地图中的每个瓦片的宽度，像素坐标中	的y除以瓦点地图中的每个瓦片的高度，这样我们就可以获得当前人物需要交互的瓦点地图位置

#### 小结

在 Cocos2d-x 中，世界坐标系以屏幕左下角为原点，而 TMX 瓦片地图通常以左上角为基准，需要特别注意行列翻转问题。人物在世界坐标系中的位置减去地图在世界坐标系的位置，可以换算得到该人物在地图中的像素坐标；再将该像素坐标分别除以瓦片宽度和高度，即可获取相应的瓦片坐标。正确理解并应用这些坐标转换逻辑，能有效避免渲染错位和碰撞检测不准等常见问题。

## 代码的架构从高耦合到低耦合

**1. 初始阶段：高耦合场景**

- 现象：在刚开始的场景的构建中，我们把所有的逻辑都堆在`FarmMap`中，例如鼠标监听器、键盘监听器、UI、npc初始化等

- 问题：

  1.**可读性差**：所有代码混杂在一起，即使有详细的注释，也很难对每个功能进行区分

  2.**开发困难**：没有合理的封装，代码逻辑的直接堆砌会给星露谷的开发带来巨大的困难，修改某个功能容易牵一发而动全身

  3.**扩展困难**：当要添加新功能或逻辑时，需要频繁改动原有代码，容易产生意外BUG。

**2. 中间阶段：拆分代码**

- 思路：我们根据每个函数、模块的功能进行划分，将其拆分程若干个功能互不相同的”组件“。

  例如，我们可以将人物与npc的交互合成一个组件，各种监听器组成Control组件。这样我们组件各自拥有独立的成员变量与方法，只对外提供必要的接口即可。

**3. 最终目标：低耦合、可拓展**

- **模块职责更清晰**：每个组件只关心自己的核心逻辑，实现“单一职责”。

- **接口规范**：统一对外提供清晰的 API 或事件机制，不同组件之间可以松散耦合。

- **高内聚**：组件内部逻辑紧凑，外部对其内部实现不感知、不干涉。

## 代码的重构

#### 1. 目标

- **NPC 只当成 NPC**：负责游戏任务、对话、移动等。
- **地图只当成地图**：负责地图数据、渲染、碰撞信息、农场耕种等等。
- **玩家只当成玩家**：负责玩家输入、属性、技能等。
- **SceneMap 负责交互**：与 NPC、地图、玩家打交道，实现整体协同。

#### 2. 重构思路

1. **提前想好基类和派生类**

   - 当发现多个类具有相似功能或属性时，先抽取出一个 基类 (Base Class)，将通用逻辑集中放置。

   - 对每个不同的需求，再用 派生类 (Derived Class) 去扩展。

   - 例如我们在背包构建中，我们可以把背包所有的物品抽象出Item类，包含物品的名称等通用物品属性与方法。从Item中我们又可以派生出Food、Tool等抽象类，表述不同类型的工具的一些共用的方法。这样可以减少代码重复、增加可拓展性，同时逻辑清楚明了。

2. **当发现一个类会被写很多个相似的类时，及时添加基类**

   - 这是代码膨胀时常见的“信号”：大量复制粘贴相似逻辑会大幅提高维护难度。
   - 在重构中，抽象出公共部分放入基类或通用组件，可有效降低后续开发成本。

3. **角色职责拆分：NPC、地图、玩家三者分离**

   - `NPC` 类
     - 只关心 NPC 自身的状态、位置、对话、动画等。
     - 对外提供简洁的接口等。
   - 地图类（`Map`）
     - 管理地图资源（如 TMX 文件）、瓦片大小、地图上不同图块的属性。
     - 管理地图上的不同图块的属性，
     - 提供getTileGID（） 、interact（）之类的方法给外部调用，实现人物与地图的交互。
   - 玩家类（`Player`）
     - 专注玩家的输入处理、属性/装备/技能等。
     - 接收或触发与 NPC、地图的交互请求，从而实现物品的获得、人物的升级等。

4. **SceneMap 负责交互**
   - 在 `SceneMap`统一协调 NPC、地图、玩家之间的逻辑：
     - 例如，当玩家移动时，需要检测地图是否可通行；若碰到 NPC，则触发对话或任务；
     - 当出现点击事件时，我们获得当前人物的工具以及位置交由地图处理。地图处理完毕后，再将交互所得结果返还给人物玩家/
   - 这样保证了 NPC、地图、玩家彼此间的低耦合，它们只需与 `SceneMap` 通讯。

#### 3.小结

通过这样的重构思路，我们能够将系统中的人物、NPC、地图等核心组件进行合理的拆分和继承。基类-派生类机制可以有效减少重复代码，SceneMap 的中心调度角色则让整体业务逻辑更清晰、可维护。

重构的思路：

	- 提前想好基类和派生类
	- 当发现一个类需要会被写很多个相似的类时添加基类

# 开发项目过程学习到的知识

## c++相关

- **面向对象编程（OOP）**

  面向对象的核心概念包含封装、继承、多态三大特性。

  - **封装：**将类的内部数据和实现细节对外隐藏，只提供暴露公共接口的方法，这样能够提升代码安全与维护性。不仅如此，封装可以将功能封装在类中，可以更容易地重用已经实现地功能，同时还能将对象之间的耦合度降低，使得系统更加灵活和易于拓展，使得对象之间的关系更加清晰和简单。
  - **继承：**继承性是面向对象编程中的一个重要特性，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承的主要目的是实现代码的重用和扩展。通过继承，可以在已有类的基础上创建新的类，新类可以继承父类的成员变量和成员函数，同时还可以添加自己的新成员。这样可以减少代码的重复编写，提高开发效率，并且使代码更加易于维护和扩展。
  - **多态：**多态可以提高代码的可扩展性，使得代码更加灵活和可扩展。当需要添加新的子类时，不需要修改现有的代码，只需要在新子类中实现相应的方法即可。多态允许使用基类指针或引用来操作派生类对象，可以编写通用的代码来处理不同类型的对象，从而提高代码的重用性。多态是基于动态绑定实现的，这意味着在运行时才确定调用哪个方法。这使得程序能够根据对象的实际类型来执行相应的操作，增加了代码的灵活性。多态使得代码更好维护，由于多态使用了继承和虚函数，使得代码的结构更加清晰和易于理解。当需要修改或扩展代码时，更容易定位和修改相关的部分。

- **范式编程**

  范式编程的核心在于通过模板 (Template) 将通用算法与数据结构进行抽象，从而对任意类型都可复用。范式编程具有以下的特点：

  - **灵活性**：一段代码可适用于多种数据类型，避免重复编写。

  - **效率**：模板是在编译期生成针对具体类型的实例化代码，不需要运行时开销。

  - **整洁性**：高层逻辑能保持简洁，复用性显著提升。

- 用到的c++ 11 的特性
  - `Auto`
  
    在变量声明时使用 `auto`，让编译器根据初始化表达式来推断类型。一方面，它减少冗长类型声明，尤其在使用 STL 容器或迭代器时，能让代码更简洁；另一方当面，可以减少潜在类型错误，通过自动推断减少手动声明出错的可能。星露谷游戏开发中的示例：
  
    ```c++
    for (auto item : items) {
    		if (item) {
    			if (item->getItemName() == targetName) {
    				return true;
    			}
    		}
    	}
    ```
  
  - `dynamic_cast `
  
    在多态体系中，用于在运行时进行类型安全的强制转换。只能在含有虚函数的类层次结构中使用，在类型不匹配时返回 nullptr，避免无效转换造成崩溃。星露谷游戏中的开发示例：
  
    ```C++
    // 操作之后更新soil土壤块
        dynamic_cast<Soil*>(mapTileNode[x][y])->updateGID();
        int soilGID = dynamic_cast<Soil*>(mapTileNode[x][y])->getCurrentGID();
        soilLayer->setTileGID(soilGID,Vec2(x,y));
    ```
  
  - `lambda`表达式
  
    lambda表达式是一种简便的匿名函数写法，可在函数内部快速定义并使用闭包（捕获外部变量），像事件响应、遍历等场景无需额外定义函数。能够把当前上下文中的局部变量以值或引用方式捕获进匿名函数里使用。星露谷游戏中的开发示例：
  
    ```c++
    // 这个lambda函数会在FarmMap的生存期内每帧时间调用一次
        schedule([this](float dt) {
            // 检查目标位置是否是障碍物
            auto player = Player::getInstance();
    
            // 人在地图坐标中下一步会到达的位置
            Vec2 playerSize2 = Vec2(0.0f, player->getContentSize().height * 1.0f);
    
            auto playerPositionInMap = player->getPosition() - getPosition() - playerSize2 * 0.5f + player->getVelocity() / MAP_MOVE_SPEED * 10.0f;
            if (isCollidable(playerPositionInMap)) {
                 velocity = Vec2::ZERO;
                 player->stopMoving();
            }
            auto position = getPosition() + velocity * dt;
            // max保证大于等于下界， min保证小于等于上界
            position.x = std::max(WINSIZE.width - getMapSize().width, std::min(position.x, 0.0f));
            position.y = std::max(WINSIZE.height - getMapSize().height, std::min(position.y, 0.0f));
    
            setPosition(position);
            }, "farm_map");
    ```
  
  - Override
  
    显式表明该虚函数是重写父类对应的虚函数，让编译器帮忙检查是否真正重写成功。一方面这样避免拼写错误，如果函数签名不匹配父类，编译器会报错；一方面代码更易读，一眼能看出该函数是重写父类方法。星露谷游戏中的开发示例：
  
    ```c++
    // 更新图块
    void updateGID() override;
    ```
  
  - `constexpr`
  
    在编译期即可确定的常量表达式，用于声明可在编译期间求值的变量或函数。这样一方面可以带来性能提升，很多计算可在编译阶段完成，运行时无额外开销。另一方面只能使用字面值或其他 constexpr 量进行初始化，避免了运行时不确定因素。星露谷游戏中的开发示例：
  
    ```C++
    // FarmMap
    constexpr int FARMMAP_SIZE_WIDTH = 1980;
    constexpr int FARMMAP_SIZE_HEIGHT = 1080;
    constexpr int FARMMAP_WIDTH = 31;
    constexpr int FARMMAP_HEIGHT = 17;
    constexpr int SUN_OFFSET = 100;
    constexpr float CHANGE_MAP_DISTANCE = 80.0f;
    ```
  
  - 枚举类 安全
  
    区别于旧式枚举，它有两方面的优点：①作用域更安全：`enum class` 的枚举值必须使用 `EnumName::Value` 访问，避免与其他枚举或全局变量冲突。②类型安全：不能隐式转换为整数，需要显式转换，防止误用。星露谷游戏中的开发示例：
  
    ```c++
    // 天气的枚举类
    enum class Weather {
        Sunny,
        LightRain,
        HeavyRain,
        Snowy,
    };
    ```

## cocos2d相关

**核心组件**：

- **Director**：管理游戏的主循环，控制场景的切换和渲染。
- **Scene**：游戏中的各个独立场景，如主菜单、关卡、游戏结束等。
- **Layer**：场景中的子层，用于组织不同类型的节点，如背景层、游戏对象层、UI 层等。
- **Node**：Cocos2d-x 中的基本元素，所有可显示的对象（如精灵、标签、按钮）都是 Node 的子类。
- **Sprite** 是 Cocos2d-x 中最基本的可渲染对象，用于显示图像、动画和其他视觉元素。它是所有可见节点（如人物、道具、背景元素等）的基础。

